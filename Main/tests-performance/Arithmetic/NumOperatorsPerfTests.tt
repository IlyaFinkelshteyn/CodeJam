<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
<#@ include file="$(SolutionDir)Main\src\Arithmetic\Operators.ttinclude" #>
using System;

using BenchmarkDotNet.NUnit;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;

using static CodeJam.AssemblyWideConfig;

namespace CodeJam.Arithmetic
{
	[TestFixture(Category = PerfTestsConstants.PerfTestCategory + ": Operators (generated)")]
	[CompetitionMetadata("CodeJam.Arithmetic.NumOperatorsPerfTests.generated.xml")]
	[Explicit("Server run speed not stable")]
	public class NumOperatorsPerfTests
	{
<#bool addFirstRegion = false;
foreach (var op in ops) {
	if (op.OpType == OpType.Comparison)
		continue;
	bool addFirst = false;
	WriteSeparatorLine(ref addFirstRegion);#>
		#region <#=op.Name#>
<#
	if (op.OpType == OpType.Unary) {
		WriteSeparatorLine(ref addFirst);#>
		[Test]
		public void RunInt<#=op.Name#>Case() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case : IntOperatorsBaseCase
		{
			private readonly Func<int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public int <#=op.Name#>Baseline()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = <#=op.Sign#>ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int <#=op.Name#>Operator()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _int<#=op.Name#>(ValuesB[i]);
				return result;
			}
		}
<#	}#>
<#	else if (op.OpType == OpType.Binary) {
		WriteSeparatorLine(ref addFirst);#>
		[Test]
		public void RunInt<#=op.Name#>Case() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public int <#=op.Name#>Baseline()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] <#=op.Sign#> ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int <#=op.Name#>Operator()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _int<#=op.Name#>(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
<#		if (!op.IntOnly) {#>

		[Test]
		public void RunNullableDouble<#=op.Name#>Case() => CompetitionBenchmarkRunner.Run<NullableDouble<#=op.Name#>Case>(RunConfig);

		public class NullableDouble<#=op.Name#>Case : NullableDoubleOperatorsBaseCase
		{
			private readonly Func<double?, double?, double?> _double<#=op.Name#> = NullableDoubleOp.<#=op.Name#>;

			[CompetitionBaseline]
			public double? <#=op.Name#>Baseline()
			{
				double? result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] <#=op.Sign#> ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? <#=op.Name#>Operator()
			{
				double? result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _double<#=op.Name#>(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
<#		}#>
<#	}#>
		#endregion
<#}#>
	}
}