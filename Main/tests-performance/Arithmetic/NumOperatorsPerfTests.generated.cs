//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

using BenchmarkDotNet.NUnit;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;

using static CodeJam.AssemblyWideConfig;

namespace CodeJam.Arithmetic
{
	[TestFixture(Category = PerfTestsConstants.PerfTestCategory + ": Operators (generated)")]
	[CompetitionMetadata("CodeJam.Arithmetic.NumOperatorsPerfTests.generated.xml")]
	[Explicit("Server run speed not stable")]
	public class NumOperatorsPerfTests
	{
		#region Unary
		#region UnaryMinus
		[Test]
		public void RunIntUnaryMinusCase() => CompetitionBenchmarkRunner.Run<IntUnaryMinusCase>(RunConfig);

		public class IntUnaryMinusCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int> _opUnaryMinus = Operators<int>.UnaryMinus;

			[CompetitionBaseline]
			public int UnaryMinusBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = -ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public  int UnaryMinusOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opUnaryMinus(ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region OnesComplement
		[Test]
		public void RunIntOnesComplementCase() => CompetitionBenchmarkRunner.Run<IntOnesComplementCase>(RunConfig);

		public class IntOnesComplementCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int> _opOnesComplement = Operators<int>.OnesComplement;

			[CompetitionBaseline]
			public int OnesComplementBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ~ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public  int OnesComplementOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opOnesComplement(ValuesB[i]);
				return result;
			}
		}
		#endregion
		#endregion

		#region Binary
		#region Plus
		[Test]
		public void RunIntPlusCase() => CompetitionBenchmarkRunner.Run<IntPlusCase>(RunConfig);

		public class IntPlusCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opPlus = Operators<int>.Plus;

			[CompetitionBaseline]
			public int PlusBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] + ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int PlusOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opPlus(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

		[Test]
		public void RunNullableDoublePlusCase() => CompetitionBenchmarkRunner.Run<NullableDoublePlusCase>(RunConfig);

		public class NullableDoublePlusCase : NullableDoubleOperatorsBaseCase
		{
			private readonly Func<double?, double?, double?> _opPlus = Operators<double?>.Plus;

			[CompetitionBaseline]
			public double? PlusBaseline()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] + ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? PlusOperator()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opPlus(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region Minus
		[Test]
		public void RunIntMinusCase() => CompetitionBenchmarkRunner.Run<IntMinusCase>(RunConfig);

		public class IntMinusCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opMinus = Operators<int>.Minus;

			[CompetitionBaseline]
			public int MinusBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] - ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int MinusOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opMinus(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

		[Test]
		public void RunNullableDoubleMinusCase() => CompetitionBenchmarkRunner.Run<NullableDoubleMinusCase>(RunConfig);

		public class NullableDoubleMinusCase : NullableDoubleOperatorsBaseCase
		{
			private readonly Func<double?, double?, double?> _opMinus = Operators<double?>.Minus;

			[CompetitionBaseline]
			public double? MinusBaseline()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] - ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? MinusOperator()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opMinus(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region Mul
		[Test]
		public void RunIntMulCase() => CompetitionBenchmarkRunner.Run<IntMulCase>(RunConfig);

		public class IntMulCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opMul = Operators<int>.Mul;

			[CompetitionBaseline]
			public int MulBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] * ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int MulOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opMul(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

		[Test]
		public void RunNullableDoubleMulCase() => CompetitionBenchmarkRunner.Run<NullableDoubleMulCase>(RunConfig);

		public class NullableDoubleMulCase : NullableDoubleOperatorsBaseCase
		{
			private readonly Func<double?, double?, double?> _opMul = Operators<double?>.Mul;

			[CompetitionBaseline]
			public double? MulBaseline()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] * ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? MulOperator()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opMul(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region Div
		[Test]
		public void RunIntDivCase() => CompetitionBenchmarkRunner.Run<IntDivCase>(RunConfig);

		public class IntDivCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opDiv = Operators<int>.Div;

			[CompetitionBaseline]
			public int DivBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] / ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int DivOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opDiv(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

		[Test]
		public void RunNullableDoubleDivCase() => CompetitionBenchmarkRunner.Run<NullableDoubleDivCase>(RunConfig);

		public class NullableDoubleDivCase : NullableDoubleOperatorsBaseCase
		{
			private readonly Func<double?, double?, double?> _opDiv = Operators<double?>.Div;

			[CompetitionBaseline]
			public double? DivBaseline()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] / ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? DivOperator()
			{
				var result = default(double?);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opDiv(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region Modulo
		[Test]
		public void RunIntModuloCase() => CompetitionBenchmarkRunner.Run<IntModuloCase>(RunConfig);

		public class IntModuloCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opModulo = Operators<int>.Modulo;

			[CompetitionBaseline]
			public int ModuloBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] % ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int ModuloOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opModulo(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region Xor
		[Test]
		public void RunIntXorCase() => CompetitionBenchmarkRunner.Run<IntXorCase>(RunConfig);

		public class IntXorCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opXor = Operators<int>.Xor;

			[CompetitionBaseline]
			public int XorBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] ^ ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int XorOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opXor(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region BitwiseAnd
		[Test]
		public void RunIntBitwiseAndCase() => CompetitionBenchmarkRunner.Run<IntBitwiseAndCase>(RunConfig);

		public class IntBitwiseAndCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opBitwiseAnd = Operators<int>.BitwiseAnd;

			[CompetitionBaseline]
			public int BitwiseAndBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] & ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int BitwiseAndOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opBitwiseAnd(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region BitwiseOr
		[Test]
		public void RunIntBitwiseOrCase() => CompetitionBenchmarkRunner.Run<IntBitwiseOrCase>(RunConfig);

		public class IntBitwiseOrCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opBitwiseOr = Operators<int>.BitwiseOr;

			[CompetitionBaseline]
			public int BitwiseOrBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] | ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int BitwiseOrOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opBitwiseOr(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region LeftShift
		[Test]
		public void RunIntLeftShiftCase() => CompetitionBenchmarkRunner.Run<IntLeftShiftCase>(RunConfig);

		public class IntLeftShiftCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opLeftShift = Operators<int>.LeftShift;

			[CompetitionBaseline]
			public int LeftShiftBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] << ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int LeftShiftOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opLeftShift(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion

		#region RightShift
		[Test]
		public void RunIntRightShiftCase() => CompetitionBenchmarkRunner.Run<IntRightShiftCase>(RunConfig);

		public class IntRightShiftCase : IntOperatorsBaseCase
		{
			private readonly Func<int, int, int> _opRightShift = Operators<int>.RightShift;

			[CompetitionBaseline]
			public int RightShiftBaseline()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] >> ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int RightShiftOperator()
			{
				var result = default(int);
				for (var i = 0; i < ValuesA.Length; i++)
					result = _opRightShift(ValuesA[i], ValuesB[i]);
				return result;
			}
		}
		#endregion
		#endregion
	}
}