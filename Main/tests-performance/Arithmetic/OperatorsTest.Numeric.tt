<#@ template debug="false" hostspecific="false" language="C#"
#><#@ assembly name="System.Core"
#><#@ include file="$(SolutionDir)Main\src\Arithmetic\Operators.ttinclude"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Collections.Generic"
#><#@ output extension=".generated.cs"
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.NUnit;

using JetBrains.Annotations;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;

using static CodeJam.AssemblyWideConfig;

namespace CodeJam.Arithmetic
{
	[TestFixture]
	public class NumOperatorsPerfTest
	{
		private const int _count = 100 * 1000;
<#foreach (var op in ops) {
	if (op.Unary) {#>
		public class Int<#=op.Name#>Case
		{
			private readonly Func<int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[Benchmark(Baseline = true)]
			[UsedImplicitly]
			public int <#=op.Name#>Baseline()
			{
				var res = 0;
				for (var i = 0; i < _count; i++)
					res += <#=op.Sign#>42;
				return res;
			}

			[CompetitionBenchmark(5, 15)]
			public int <#=op.Name#>Operator()
			{
				var res = 0;
				for (var i = 0; i < _count; i++)
					res += _int<#=op.Name#>(42);
				return res;
			}
		}

		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);


<#	}#>
<#	else {#>
		public class Int<#=op.Name#>Case
		{
			private readonly Func<int, int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[Benchmark(Baseline = true)]
			[UsedImplicitly]
			public int <#=op.Name#>Baseline()
			{
				var res = 0;
				for (var i = 0; i < _count; i++)
					res += 48 <#=op.Sign#> 54;
				return res;
			}

			[CompetitionBenchmark(5, 15)]
			public int <#=op.Name#>Operator()
			{
				var res = 0;
				for (var i = 0; i < _count; i++)
					res += _int<#=op.Name#>(48, 54);
				return res;
			}
		}

		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

<#		if (!op.IntOnly) {#>
		public class NullableDouble<#=op.Name#>Case
		{
			private readonly Func<double?, double?, double?> _double<#=op.Name#> = NullableDoubleOp.<#=op.Name#>;

			[Benchmark(Baseline = true)]
			[UsedImplicitly]
			public double? <#=op.Name#>Baseline()
			{
				double? res = 0;
				for (var i = 0; i < _count; i++)
					res += 48 <#=op.Sign#> 54;
				return res;
			}

			[CompetitionBenchmark(5, 15)]
			public double? <#=op.Name#>Operator()
			{
				double? res = 0;
				for (var i = 0; i < _count; i++)
					res += _double<#=op.Name#>(48, 54);
				return res;
			}
		}

		[Test]
		public void NullableDouble<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

<#		}#>
<#	}#>
<#}#>
	}
}