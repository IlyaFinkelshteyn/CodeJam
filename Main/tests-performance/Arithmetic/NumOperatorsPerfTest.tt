<#@ assembly name="System.Core"
#><#@ include file="$(SolutionDir)Main\src\Arithmetic\Operators.ttinclude"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Collections.Generic"
#><#@ output extension=".generated.cs"
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

using BenchmarkDotNet.NUnit;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;

using static CodeJam.AssemblyWideConfig;

namespace CodeJam.Arithmetic
{
	[TestFixture(Category = BenchmarkConstants.BenchmarkCategory + ": Operators (generated)")]
	[CompetitionMetadata("CodeJam.Arithmetic.NumOperatorsPerfTest.generated.xml")]	
	public class NumOperatorsPerfTest
	{
<#foreach (var op in ops) {
	if (op.Unary) {#>
		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case: IntOperatorsBenchmark<int>
		{
			private readonly Func<int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public void <#=op.Name#>Baseline()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = <#=op.Sign#>ValuesB[i];
			}

			[CompetitionBenchmark]
			public void <#=op.Name#>Operator()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = _int<#=op.Name#>(ValuesB[i]);
			}
		}

<#	}#>
<#	else {#>
		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case: IntOperatorsBenchmark<int>
		{
			private readonly Func<int, int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public void <#=op.Name#>Baseline()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = ValuesA[i] <#=op.Sign#> ValuesB[i];
			}

			[CompetitionBenchmark]
			public void <#=op.Name#>Operator()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = _int<#=op.Name#>(ValuesA[i], ValuesB[i]);
			}
		}

<#		if (!op.IntOnly) {#>
		[Test]
		public void NullableDouble<#=op.Name#>() => CompetitionBenchmarkRunner.Run<NullableDouble<#=op.Name#>Case>(RunConfig);

		public class NullableDouble<#=op.Name#>Case: NullableDoubleOperatorsBenchmark<double?>
		{
			private readonly Func<double?, double?, double?> _double<#=op.Name#> = NullableDoubleOp.<#=op.Name#>;

			[CompetitionBaseline]
			public void <#=op.Name#>Baseline()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = ValuesA[i] <#=op.Sign#> ValuesB[i];
			}

			[CompetitionBenchmark]
			public void <#=op.Name#>Operator()
			{
				for (var i = 0; i < ValuesA.Length; i++)
					Storage = _double<#=op.Name#>(ValuesA[i], ValuesB[i]);
			}
		}

<#		}#>
<#	}#>
<#}#>
	}
}