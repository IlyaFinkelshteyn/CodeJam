<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
<#@ include file="$(SolutionDir)Main\src\Arithmetic\Operators.ttinclude" #>
using System;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;
using EnumOp = CodeJam.Arithmetic.Operators<System.AttributeTargets>;
using NullableEnumOp = CodeJam.Arithmetic.Operators<System.AttributeTargets?>;

namespace CodeJam.Arithmetic
{
	partial class OperatorsTest
	{
		private static AttributeTargets? EnumValueA = AttributeTargets.Method;
		private static AttributeTargets? EnumValueB = AttributeTargets.Class;
		private static AttributeTargets? EnumValueC = null;

<#foreach (var op in ops) {
	if (op.OpType == OpType.Unary) {#>
		[Test]
		public void Int<#=op.Name#>() => Assert.AreEqual(<#=op.Sign#>42, IntOp.<#=op.Name#>(42));

<#		if (op.ForEnums) {#>
		[Test]
		public void Enum<#=op.Name#>() =>
			Assert.AreEqual(<#=op.Sign#>EnumValueA.Value, EnumOp.<#=op.Name#>(EnumValueA.Value));

		[Test]
		public void NullableEnum<#=op.Name#>()
		{
			Assert.AreEqual(<#=op.Sign#>EnumValueA, NullableEnumOp.<#=op.Name#>(EnumValueA));
			Assert.AreEqual(<#=op.Sign#>EnumValueC, NullableEnumOp.<#=op.Name#>(EnumValueC));
		}

<#		}#>
<#		if (!op.IntOnly) {#>
		[Test]
		public void NullableDouble<#=op.Name#>() => Assert.AreEqual(<#=op.Sign#>42f, NullableDoubleOp.<#=op.Name#>(42f));

<#		}#>
<#	}#>
<#	else if (op.OpType == OpType.Binary) {#>
		[Test]
		public void Int<#=op.Name#>() => Assert.AreEqual(1 <#=op.Sign#> 2, IntOp.<#=op.Name#>(1, 2));

<#		if (op.ForEnums) {#>
		[Test]
		public void Enum<#=op.Name#>() =>
			Assert.AreEqual(
				EnumValueA.Value <#=op.Sign#> EnumValueB.Value,
				EnumOp.<#=op.Name#>(EnumValueA.Value, EnumValueB.Value));

		[Test]
		public void NullableEnum<#=op.Name#>()
		{
			Assert.AreEqual(EnumValueA <#=op.Sign#> EnumValueB, NullableEnumOp.<#=op.Name#>(EnumValueA, EnumValueB));
			Assert.AreEqual(EnumValueA <#=op.Sign#> EnumValueC, NullableEnumOp.<#=op.Name#>(EnumValueA, EnumValueC));
		}

<#		}#>
<#		if (!op.IntOnly) {#>
		[Test]
		public void NullableDouble<#=op.Name#>() => Assert.AreEqual(1f <#=op.Sign#> 2f, NullableDoubleOp.<#=op.Name#>(1, 2));

<#		}#>
<#	}#>
<#	else if (op.OpType == OpType.Comparison) {#>
		[Test]
		public void Int<#=op.Name#>() => Assert.AreEqual(1 <#=op.Sign#> 2, IntOp.<#=op.Name#>(1, 2));

<#		if (op.ForEnums) {#>
		[Test]
		public void Enum<#=op.Name#>() =>
			Assert.AreEqual(
				EnumValueA.Value <#=op.Sign#> EnumValueB.Value,
				EnumOp.<#=op.Name#>(EnumValueA.Value, EnumValueB.Value));

		[Test]
		public void NullableEnum<#=op.Name#>()
		{
			Assert.AreEqual(EnumValueA <#=op.Sign#> EnumValueB, NullableEnumOp.<#=op.Name#>(EnumValueA, EnumValueB));
			Assert.AreEqual(EnumValueA <#=op.Sign#> EnumValueC, NullableEnumOp.<#=op.Name#>(EnumValueA, EnumValueC));
		}

<#		}#>
<#		if (!op.IntOnly) {#>
		[Test]
		public void NullableDouble<#=op.Name#>() => Assert.AreEqual(1f <#=op.Sign#> 2f, NullableDoubleOp.<#=op.Name#>(1, 2));

<#		}#>
<#	}#>
<#}#>
	}
}