//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;
using EnumOp = CodeJam.Arithmetic.Operators<System.AttributeTargets>;
using NullableEnumOp = CodeJam.Arithmetic.Operators<System.AttributeTargets?>;

namespace CodeJam.Arithmetic
{
	partial class OperatorsTest
	{
		private static AttributeTargets? EnumValueA = AttributeTargets.Method;
		private static AttributeTargets? EnumValueB = AttributeTargets.Class;
		private static AttributeTargets? EnumValueC = null;

		[Test]
		public void IntUnaryMinus() => Assert.AreEqual(-42, IntOp.UnaryMinus(42));

		[Test]
		public void NullableDoubleUnaryMinus() => Assert.AreEqual(-42f, NullableDoubleOp.UnaryMinus(42f));

		[Test]
		public void IntOnesComplement() => Assert.AreEqual(~42, IntOp.OnesComplement(42));

		[Test]
		public void EnumOnesComplement() =>
			Assert.AreEqual(~EnumValueA.Value, EnumOp.OnesComplement(EnumValueA.Value));

		[Test]
		public void NullableEnumOnesComplement()
		{
			Assert.AreEqual(~EnumValueA, NullableEnumOp.OnesComplement(EnumValueA));
			Assert.AreEqual(~EnumValueC, NullableEnumOp.OnesComplement(EnumValueC));
		}

		[Test]
		public void IntPlus() => Assert.AreEqual(1 + 2, IntOp.Plus(1, 2));

		[Test]
		public void NullableDoublePlus() => Assert.AreEqual(1f + 2f, NullableDoubleOp.Plus(1, 2));

		[Test]
		public void IntMinus() => Assert.AreEqual(1 - 2, IntOp.Minus(1, 2));

		[Test]
		public void NullableDoubleMinus() => Assert.AreEqual(1f - 2f, NullableDoubleOp.Minus(1, 2));

		[Test]
		public void IntMul() => Assert.AreEqual(1 * 2, IntOp.Mul(1, 2));

		[Test]
		public void NullableDoubleMul() => Assert.AreEqual(1f * 2f, NullableDoubleOp.Mul(1, 2));

		[Test]
		public void IntDiv() => Assert.AreEqual(1 / 2, IntOp.Div(1, 2));

		[Test]
		public void NullableDoubleDiv() => Assert.AreEqual(1f / 2f, NullableDoubleOp.Div(1, 2));

		[Test]
		public void IntModulo() => Assert.AreEqual(1 % 2, IntOp.Modulo(1, 2));

		[Test]
		public void IntXor() => Assert.AreEqual(1 ^ 2, IntOp.Xor(1, 2));

		[Test]
		public void EnumXor() =>
			Assert.AreEqual(
				EnumValueA.Value ^ EnumValueB.Value,
				EnumOp.Xor(EnumValueA.Value, EnumValueB.Value));

		[Test]
		public void NullableEnumXor()
		{
			Assert.AreEqual(EnumValueA ^ EnumValueB, NullableEnumOp.Xor(EnumValueA, EnumValueB));
			Assert.AreEqual(EnumValueA ^ EnumValueC, NullableEnumOp.Xor(EnumValueA, EnumValueC));
		}

		[Test]
		public void IntBitwiseAnd() => Assert.AreEqual(1 & 2, IntOp.BitwiseAnd(1, 2));

		[Test]
		public void EnumBitwiseAnd() =>
			Assert.AreEqual(
				EnumValueA.Value & EnumValueB.Value,
				EnumOp.BitwiseAnd(EnumValueA.Value, EnumValueB.Value));

		[Test]
		public void NullableEnumBitwiseAnd()
		{
			Assert.AreEqual(EnumValueA & EnumValueB, NullableEnumOp.BitwiseAnd(EnumValueA, EnumValueB));
			Assert.AreEqual(EnumValueA & EnumValueC, NullableEnumOp.BitwiseAnd(EnumValueA, EnumValueC));
		}

		[Test]
		public void IntBitwiseOr() => Assert.AreEqual(1 | 2, IntOp.BitwiseOr(1, 2));

		[Test]
		public void EnumBitwiseOr() =>
			Assert.AreEqual(
				EnumValueA.Value | EnumValueB.Value,
				EnumOp.BitwiseOr(EnumValueA.Value, EnumValueB.Value));

		[Test]
		public void NullableEnumBitwiseOr()
		{
			Assert.AreEqual(EnumValueA | EnumValueB, NullableEnumOp.BitwiseOr(EnumValueA, EnumValueB));
			Assert.AreEqual(EnumValueA | EnumValueC, NullableEnumOp.BitwiseOr(EnumValueA, EnumValueC));
		}

		[Test]
		public void IntLeftShift() => Assert.AreEqual(1 << 2, IntOp.LeftShift(1, 2));

		[Test]
		public void IntRightShift() => Assert.AreEqual(1 >> 2, IntOp.RightShift(1, 2));

	}
}