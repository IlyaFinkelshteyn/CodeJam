<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
<#@ include file="Operators.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

using static CodeJam.Arithmetic.OperatorsFactory;

namespace CodeJam.Arithmetic
{
	/// <summary>
	/// Callbacks for common arithmetic actions.
	/// Look at OperatorsPerformanceTest to see why.
	/// </summary>
	static partial class Operators<T>
	{
<#
	OpType? prevType = null;
	foreach (var op in ops)
	{
		if (prevType != op.OpType)
		{
			if (prevType != null)
			{#>
		#endregion

<#			}#>
		#region <#=op.OpType#>
<#		}
		else
		{#>

<#		}
		prevType = op.OpType;

		if (op.OpType == OpType.Comparison)
		{#>
		private static readonly Lazy<Func<T, T, bool>> _<#=op.LowerName#> =
			new Lazy<Func<T, T, bool>>(() => ComparisonOperator<T>(ExpressionType.<#=op.Type#>), LazyMode);
		
		/// <summary><#=op.Name#> operator.</summary>
		/// <value>The <#=op.Name#> operator.</value>
		[NotNull]
		public static Func<T, T, bool> <#=op.Name#> => _<#=op.LowerName#>.Value;
<#		}
		else if (op.OpType == OpType.Unary)
		{#>
		private static readonly Lazy<Func<T, T>> _<#=op.LowerName#> =
			new Lazy<Func<T, T>>(() => UnaryOperator<T>(ExpressionType.<#=op.Type#>), LazyMode);

		/// <summary><#=op.Name#> operator.</summary>
		/// <value>The <#=op.Name#> operator.</value>
		[NotNull]
		public static Func<T, T> <#=op.Name#> => _<#=op.LowerName#>.Value;
<#		}
		else
		{#>
		private static readonly Lazy<Func<T, T, T>> _<#=op.LowerName#> =
			new Lazy<Func<T, T, T>>(() => BinaryOperator<T>(ExpressionType.<#=op.Type#>), LazyMode);

		/// <summary><#=op.Name#> operator.</summary>
		/// <value>The <#=op.Name#> operator.</value>
		[NotNull]
		public static Func<T, T, T> <#=op.Name#> => _<#=op.LowerName#>.Value;
<#		}
	}
	if (prevType != null)
	{#>
		#endregion
<#	}#>
	}
}