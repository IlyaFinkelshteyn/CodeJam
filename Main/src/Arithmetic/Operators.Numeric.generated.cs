//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq.Expressions;
using System.Threading;

using JetBrains.Annotations;

using static CodeJam.Arithmetic.OperatorsFactory;

namespace CodeJam.Arithmetic
{
	partial class Operators<T>
	{
		private static readonly Lazy<Func<T, T, T>> _plus
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Add), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Plus operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Plus => _plus.Value;

		private static readonly Lazy<Func<T, T, T>> _minus
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Subtract), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Minus operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Minus => _minus.Value;

		private static readonly Lazy<Func<T, T, T>> _mul
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Multiply), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Mul operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Mul => _mul.Value;

		private static readonly Lazy<Func<T, T, T>> _div
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Divide), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Div operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Div => _div.Value;

		private static readonly Lazy<Func<T, T, T>> _modulo
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Modulo), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Modulo operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Modulo => _modulo.Value;

		private static readonly Lazy<Func<T, T, T>> _xor
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.ExclusiveOr), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// Xor operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> Xor => _xor.Value;

		private static readonly Lazy<Func<T, T, T>> _bitwiseand
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.And), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// BitwiseAnd operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> BitwiseAnd => _bitwiseand.Value;

		private static readonly Lazy<Func<T, T, T>> _bitwiseor
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.Or), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// BitwiseOr operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> BitwiseOr => _bitwiseor.Value;

		private static readonly Lazy<Func<T, T, T>> _leftshift
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.LeftShift), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// LeftShift operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> LeftShift => _leftshift.Value;

		private static readonly Lazy<Func<T, T, T>> _rightshift
			= new Lazy<Func<T, T, T>>(() => CreateNumOperFunc<T>(ExpressionType.RightShift), LazyThreadSafetyMode.PublicationOnly);

		/// <summary>
		/// RightShift operator.
		/// </summary>
		[NotNull]
		public static Func<T, T, T> RightShift => _rightshift.Value;

	}
}