<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
<# const int count = 8; #>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using JetBrains.Annotations;

namespace CodeJam
{
	/// <summary>
	/// Provides static methods for creating tuple structs.
	/// </summary>
	[PublicAPI]
	public static class ValueTuple
	{
<#for (var i = 2; i <= count; i++) {#>
		/// <summary>
		/// Creates a new <#=i#>-tuple.
		/// </summary>
<#
	var typeList = List(i, j => "T" + j);
	for (var j = 1; j <= i; j++) {#>
		/// <param name="item<#=j#>">The value of the component <#=j#> of the tuple.</param>
		/// <typeparam name="T<#=j#>">The type of the component <#=j#> of the tuple.</typeparam>
<#	}#>
		/// <returns>A <#=i#>-tuple whose value is (item1, item2).</returns>
		[Pure]
		public static ValueTuple<<#=typeList#>> Create<<#=typeList#>>(<#=List(i, j => "T" + j + " item" + j)#>) =>
			new ValueTuple<<#=typeList#>>(<#=List(i, j => "item" + j)#>);

<#}#>
	}

<#for (var i = 2; i <= count; i++) {#>
	/// <summary>
	/// Represents a <#=i#>-tuple.
	/// </summary>
<#
	var typeList = List(i, j => "T" + j);
	for(var j = 1; j <= i; j++) {#>
	/// <typeparam name="T<#=j#>">The type of the component <#=j#> of the tuple.</typeparam>
<#	}#>
	[Serializable]
	[PublicAPI]
	public struct ValueTuple<<#=typeList#>> : IValueTuple, IStructuralEquatable, IStructuralComparable, IComparable
	{
<#	for (var j = 1; j <= i; j++) {#>
		/// <summary>
		/// The value of the component <#=j#> of the tuple.
		/// </summary>
		public T<#=j#> Item<#=j#> { get; }

<#	}#>
		/// <summary>
		/// Initialize instance.
		/// </summary>
<#	for (var j = 1; j <= i; j++) {#>
		/// <param name="item<#=j#>">Item <#=j#> value.</param>
<#	}#>
		public ValueTuple(<#=List(i, j => "T" + j + " item" + j)#>)
		{
<#	for (var j = 1; j <= i; j++) {#>
			Item<#=j#> = item<#=j#>;
<#	}#>
		}

		/// <summary>
		/// Determines whether the specified object is equal to the current object.
		/// </summary>
		/// <returns>
		/// true if the specified object  is equal to the current object; otherwise, false.
		/// </returns>
		/// <param name="obj">The object to compare with the current object. </param>
		[Pure]
		public override bool Equals(object obj) =>
			((IStructuralEquatable)this).Equals(obj, EqualityComparer<object>.Default);

		bool IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
		{
			if (!(other is ValueTuple<<#=typeList#>>))
				return false;

			var objTuple = (ValueTuple<<#=typeList#>>)other;
			return <#=List(i, j => "comparer.Equals(Item" + j + ", objTuple.Item" + j + ")", " && ")#>;
		}

		int IComparable.CompareTo(object obj) => ((IStructuralComparable)this).CompareTo(obj, Comparer<object>.Default);

		int IStructuralComparable.CompareTo(object other, IComparer comparer)
		{
			if (other == null) return 1;

			Code.AssertArgument(other is ValueTuple<<#=typeList#>>, nameof (other), "Incorrect tuple");

			var objTuple = (ValueTuple<<#=typeList#>>)other;
			int c = 0;
<#	for (var j = 1; j < i; j++) {#>
			c = comparer.Compare(Item<#=j#>, objTuple.Item<#=j#>);
			if (c != 0) return c;
<#	}#>
			return comparer.Compare(Item<#=i#>, objTuple.Item<#=i#>);
		}

		/// <summary>
		/// Returns the hash code for this instance.
		/// </summary>
		/// <returns>
		/// A 32-bit signed integer that is the hash code for this instance.
		/// </returns>
		[Pure]
		public override int GetHashCode() => ((IStructuralEquatable)this).GetHashCode(EqualityComparer<object>.Default);

		int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) =>
			HashCode.Combine(<#=List(i, j => "comparer.GetHashCode(Item" + j + ")")#>);

		/// <summary>
		/// Returns the fully qualified type name of this instance.
		/// </summary>
		/// <returns>
		/// A <see cref="T:System.String"/> containing a fully qualified type name.
		/// </returns>
		[Pure]
		[NotNull]
		public override string ToString()
		{
			var sb = new StringBuilder();
			sb.Append("(");
<#	for (var j = 1; j <= i; j++) {#>
			sb.Append(Item<#=j#>);
<#		if (j != i) {#>
			sb.Append(", ");
<#		}#>
<#	}#>
			return sb.ToString();
		}

		#region Implementation of IValueTuple
		int IValueTuple.Rank => <#=i#>;

		object IValueTuple.this[int index]
		{
			get
			{
				switch (index)
				{
<#	for (var j = 0; j < i; j++) {#>
					case <#=j#>: return Item<#=j+1#>;
<#	}#>
					default: throw new ArgumentOutOfRangeException(nameof(index));
				}
			}
		}
		#endregion
	}

<#}#>
}