<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
using System;
using System.Collections.Generic;

using JetBrains.Annotations;

namespace CodeJam
{
	partial class Algorithms
	{
<#
	foreach (var type in new[] { "float", "double", "TimeSpan", "DateTime", "DateTimeOffset" })
	{
#>

		#region <#= type #>
<#
		GenerateMethods(type);
#>
		#endregion
<#
	}
#>
	}
}
<#+
public void GenerateMethods(string type)
{
#>
		/// <summary>
		/// Returns the minimum index i in the range [0, list.Count - 1] such that list[i] > value
		/// or list.Count if no such i exists
		/// </summary>
		/// <param name="list">The sorted list</param>
		/// <param name="value">The value to compare</param>
		/// <returns>The upper bound for the value</returns>
		[Pure]
		public static int UpperBound([NotNull, InstantHandle] this IList<<#= type #>> list, <#= type #> value)
			=> list.UpperBound(value, 0);

		/// <summary>
		/// Returns the minimum index i in the range [from, list.Count - 1] such that list[i] > value
		/// or list.Count if no such i exists
		/// </summary>
		/// <param name="list">The sorted list</param>
		/// <param name="value">The value to compare</param>
		/// <param name="from">The minimum index</param>
		/// <returns>The upper bound for the value</returns>
		[Pure]
		public static int UpperBound([NotNull, InstantHandle] this IList<<#= type #>> list, <#= type #> value, int from)
			=> list.UpperBound(value, from, list.Count);

		/// <summary>
		/// Returns the minimum index i in the range [from, to - 1] such that list[i] > value
		/// or "to" if no such i exists
		/// </summary>
		/// <param name="list">The sorted list</param>
		/// <param name="value">The value to compare</param>
		/// <param name="from">The minimum index</param>
		/// <param name="to">The upper bound for the index (not included)</param>
		/// <returns>The upper bound for the value</returns>
		[Pure]
		public static int UpperBound([NotNull, InstantHandle] this IList<<#= type #>> list, <#= type #> value, int from, int to)
		{
			ValidateIndicesRange(from, to, list.Count);
			return UpperBoundCore(list, value, from, to);
		}

		/// <summary>
		/// Returns the minimum index i in the range [from, to - 1] such that list[i] > value
		/// or "to" if no such i exists
		/// </summary>
		/// <param name="list">The sorted list</param>
		/// <param name="value">The value to compare</param>
		/// <param name="from">The minimum index</param>
		/// <param name="to">The upper bound for the index (not included)</param>
		/// <returns>The upper bound for the value</returns>
		private static int UpperBoundCore(IList<<#= type #>> list, <#= type #> value, int from, int to)
		{
			Code.NotNull(list, nameof(list));
			while (from < to)
			{
				var median = from + (to - from) / 2;
				if (list[median] > value)
				{
					to = median;
				}
				else
				{
					from = median + 1;
				}
			}
			return from;
		}
<#+
}
#>
