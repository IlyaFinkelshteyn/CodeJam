//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;

using NUnit.Framework;

using static NUnit.Framework.Assert;

namespace CodeJam.RangesV2
{
	[TestFixture(Category = "Ranges")]
	[SuppressMessage("ReSharper", "HeapView.BoxingAllocation")]
	public partial class RangeExtensionsTests
	{
		[Test]
		public static void TestKeyedRangeMakeInclusiveExclusive()
		{
			var range = Range.Create(1, 2, '_');
			AreEqual(range, range.MakeInclusive(i => i - 1, i => i + 1));
			range = Range.CreateExclusive(1, 2, '_');
			AreEqual(Range.Create(0, 3, '_'), range.MakeInclusive(i => i - 1, i => i + 1));
			range = Range.CreateExclusiveTo(1, 2, '_');
			AreEqual(Range.Create(1, 3, '_'), range.MakeInclusive(i => i - 1, i => i + 1));

			range = Range.CreateExclusive(1, 2, '_');
			AreEqual(range, range.MakeExclusive(i => i - 1, i => i + 1));
			range = Range.Create(1, 2, '_');
			AreEqual(Range.CreateExclusive(0, 3, '_'), range.MakeExclusive(i => i - 1, i => i + 1));
			range = Range.CreateExclusiveFrom(1, 2, '_');
			AreEqual(Range.CreateExclusive(1, 3, '_'), range.MakeExclusive(i => i - 1, i => i + 1));

			range = Range.CreateExclusive(2, 3, '_');
			IsTrue(range.MakeInclusive(i => i + 1, i => i - 1).IsEmpty);
			range = Range.Create(2, 3, '_');
			IsTrue(range.MakeExclusive(i => i + 1, i => i - 1).IsEmpty);

			range = Range.CreateExclusive(2, 3, '_');
			IsTrue(range.MakeInclusive(i => i + 1, i => i - 1).IsEmpty);
			range = Range.Create(2, 3, '_');
			IsTrue(range.MakeExclusive(i => i + 1, i => i - 1).IsEmpty);

			var range2 = Range.CreateExclusive(1, double.PositiveInfinity, '_');
			IsTrue(range2.MakeInclusive(i => double.NegativeInfinity, i => i + 1).IsInfinite);
			range2 = Range.Create(double.NegativeInfinity, 2, '_');
			IsTrue(range2.MakeExclusive(i => i + 1, i => double.PositiveInfinity).IsInfinite);
			range2 = Range.Create(double.NegativeInfinity, double.PositiveInfinity, '_');
			AreEqual(range2, range2.MakeInclusive(i => i - 1, i => i + 1));
		}

		[Test]
		public static void TestKeyedRangeWithValue()
		{
			var range = Range.Create(1, 2, '_');
			AreEqual(Range.Create(0, 3, '_'), range.WithValues(i => i - 1, i => i + 1));

			range = Range.CreateExclusiveFrom(1, 2, '_');
			AreEqual(Range.CreateExclusiveFrom(0, 3, '_'), range.WithValues(i => i - 1, i => i + 1));

			range = Range.CreateExclusive(1, 2, '_');
			AreEqual(Range.CreateExclusive(2, 3, '_'), range.WithValues(i => i + 1));

			var toInf = (double?)double.PositiveInfinity;
			var range2 = Range.CreateExclusive(1, toInf, '_');
			IsTrue(range2.WithValues(i => null).IsInfinite);
			range2 = Range.Create(double.NegativeInfinity, toInf, '_');
			AreEqual(range2, range2.WithValues(i => i - 1, i => i + 1));
		}

		[Test]
		public static void TestKeyedRangeWithKey()
		{
			var range = Range.Create(1, 2, '_');
			AreEqual(range.WithKey('^'), Range.Create(1, 2, '^'));
			AreEqual(range.WithKey('^').WithoutKey(), new Range<int>(1, 2));

			var toInf = (double?)double.PositiveInfinity;
			var range2 = Range.CreateExclusive(1, toInf, '_');
			AreEqual(range2.WithKey('^').Key, '^');
		}
	}
}