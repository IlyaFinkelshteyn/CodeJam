using System;
using System.Diagnostics.CodeAnalysis;

using CodeJam.Arithmetic;

using JetBrains.Annotations;

using static CodeJam.RangesV2.RangeInternal;

namespace CodeJam.RangesV2
{
	// The file contains members that could not be autogenerated from Range<T>.

	/// <summary>Describes a keyed range of the values</summary>
	public partial struct Range<T, TKey>
	{
		private static readonly Func<TKey, TKey, bool> _keyEqualityFunc = Operators<TKey>.AreEqual;

		/// <summary>The value associated with the range.</summary>
		/// <value>The value of the range key.</value>
		public TKey Key { get; }

		#region IRangeFactory members
		/// <summary>Creates a new instance of the range.</summary>
		/// <param name="from">Boundary From.</param>
		/// <param name="to">Boundary To.</param>
		/// <returns>A new instance of the range with specified From-To boundaries.</returns>
		[Pure]
		Range<T, TKey> IRangeFactory<T, Range<T, TKey>>.CreateRange(RangeBoundaryFrom<T> from, RangeBoundaryTo<T> to) =>
			new Range<T, TKey>(from, to, Key);

		/// <summary>Creates a new instance of the range without validating its boundaries.</summary>
		/// <param name="from">Boundary From.</param>
		/// <param name="to">Boundary To.</param>
		/// <returns>A new instance of the range with specified From-To boundaries.</returns>
		[Pure]
		[Obsolete(SkipsArgValidationObsolete)]
		Range<T, TKey> IRangeFactory<T, Range<T, TKey>>.CreateRangeUnsafe(RangeBoundaryFrom<T> from, RangeBoundaryTo<T> to) =>
			new Range<T, TKey>(from, to, Key, SkipsArgValidation);

		/// <summary>Creates a new instance of the range, if possible.</summary>
		/// <param name="from">Boundary From.</param>
		/// <param name="to">Boundary To.</param>
		/// <returns>
		/// A new instance of the range with specified From-To boundaries,
		/// or empty range, if from-to boundaries forms invalid range pair.
		/// </returns>
		[Pure]
		Range<T, TKey> IRangeFactory<T, Range<T, TKey>>.TryCreateRange(RangeBoundaryFrom<T> from, RangeBoundaryTo<T> to) =>
			Range.TryCreate(from, to, Key);
		#endregion

		#region IEquatable<Range<T, TKey>>
		/// <summary>Indicates whether the current range is equal to another.</summary>
		/// <param name="other">An range to compare with this.</param>
		/// <returns>
		/// <c>True</c> if the current range is equal to the <paramref name="other"/> parameter;
		/// otherwise, false.
		/// </returns>
		public bool Equals(Range<T, TKey> other) =>
			From == other.From && To == other.To && _keyEqualityFunc(Key, other.Key);

		/// <summary>Returns a hash code for the current range.</summary>
		/// <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
		public override int GetHashCode() =>
			HashCode.Combine(
				From.GetHashCode(),
				To.GetHashCode(),
				Key?.GetHashCode() ?? 0);
		#endregion

		#region ToString
		/// <summary>Returns string representation of the range.</summary>
		/// <returns>The string representation of the range.</returns>
		[Pure]
		public override string ToString() =>
			KeyPrefixString + Key + KeySeparatorString +
				(IsEmpty ? EmptyString : From + SeparatorString + To);

		/// <summary>
		/// Returns string representation of the range using the specified format string.
		/// If <typeparamref name="T"/> does not implement <seealso cref="IFormattable"/> the format string is ignored.
		/// </summary>
		/// <param name="format">The format string.</param>
		/// <param name="formatProvider">The format provider.</param>
		/// <returns>The string representation of the range.</returns>
		[SuppressMessage("ReSharper", "ArrangeRedundantParentheses")]
		[Pure]
		public string ToString(string format, IFormatProvider formatProvider) =>
			KeyPrefixString + Key + KeySeparatorString +
				(IsEmpty
					? EmptyString
					: (From.ToString(format, formatProvider) + SeparatorString + To.ToString(format, formatProvider)));
		#endregion
	}
}